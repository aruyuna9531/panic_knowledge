# panic_knowledge
关于go panic/recover的一些原理和实际应用

panic_recover.go 自定义recover打印

简单的写法就是print(recover())然后debug.StackTrace()就行了，程序也能继续跑（主要是原始格式不好看）

------
recover原理：修改一个_panic的recovered为true使gopanic判定当前panic恢复上层寄存器执行。如果值为false（即没跑过recover）则会将gopanic流程引到os.Exit

recover只能写在defer里，因为panic的逻辑是跑一遍defer链然后退出，只有写到defer里的recover才能改到那个recovered

调用链上先执行的recover管不到后发生的panic，如果它头顶的defer里有panic那还会panic

无论recover状况如何，defer链一定会跑完

写了recover的地方可以管到所在函数内后续所有代码，包括调用函数的地方如果在调用的那个函数里面发生panic，如果里面没有recover捕捉它，这个recover仍然能捕捉到它，但捕捉完后那个触发了panic的函数所在位置后续的代码不会被执行，这个recover所在的函数也会退出，外面会正常执行

（因此如果使用了select-case驱动业务线逻辑，recover要写到case下调用的函数里（必须是调用的函数里面，不是case自己的下面，select外面套for不能在里面写defer的），写到for-select-case外面抓一次这个loop就没了）

recover管不到非自己所在协程的panic，如果别的协程要抓panic要在协程执行的函数里另外带recover

多个协程的进程里只要有1个协程发生了panic并且没有被recover，都会触发os.Exit

cgo的代码发生异常不能被recover捕捉（它不算panic）

关于panic：

所有函数内panic位置的后续代码都不会执行

panic发生后只会按函数内注册的所有defer倒序输出，然后退出这个函数（所以recover一定要写在defer里），并且如果当前函数没有recover捕捉它，就会往函数外抛出一个panic信号（被抛出panic信号的外层函数后续不会执行；外面的recover可以捕捉它；如果抛到main都没有recover抓它，就会os.Exit——不过抛到main再抓，也为时已晚了，main函数会执行完“正常退出”）

所以服务器要运行期间不受panic宕机，正确的函数调用如no_panic_exit_example.go所示。